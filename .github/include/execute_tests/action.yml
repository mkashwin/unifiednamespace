name: Execute Tests
description: Execute all tests
inputs:
  module:
    description: 'the actual module on which the tests should run. "."  for all modules'
    required: True
    default: "."
  integration_tests:
    description: "Boolean, If True all tests should run. If False skip tests tagged for integration"
    required: False
    default: "false"
  pytest_flags:
    description: "String, additional flags to be passed to pytest while running tests"
    required: False
    default: ""
  SAFETY_API_KEY:
    description: "API Key to invoke safety scanner. see https://safetycli.com/"
    required: True
  timeout_minutes:
    description: "Timeout in minutes for the test execution"
    required: False
    default: ""
  max_attempts:
    description: "Maximum number of attempts to run the tests"
    required: False
    default: "1"

runs:
  using: "composite"
  steps:
    - name: Lint with ruff
      shell: bash
      run: |
        # change to current directory of module        
        cd ./${{ inputs.module }} 
        # stop the build if there are Python syntax errors or undefined names
        poetry run ruff check --output-format=github  --select=E9,F63,F7,F82  .
        # exit-zero treats all errors as warnings. report all other errors but don't fail the job
        poetry run ruff check --output-format=github --exit-zero .

    - name: Test with pytest
      shell: bash
      run: |
        # change to current directory of module            
        cd ./${{ inputs.module }}
        if [[ ${RUNNER_DEBUG} == 1 ]] ; then
          PYTEST_CMD="poetry run pytest --debug "
        else
          PYTEST_CMD="poetry run pytest"
        fi
          
        ATTEMPTS=0
        MAX_ATTEMPTS=${{ inputs.max_attempts }}
        SUCCESS=false

        while [ $ATTEMPTS -lt $MAX_ATTEMPTS ]; do
          if ${{ inputs.integration_tests }} ; then
            $PYTEST_CMD ${{inputs.pytest_flags}} &
          else
            $PYTEST_CMD ${{inputs.pytest_flags}} -m "not integrationtest" &
          fi

          # Get the PID of the last background command
          PID=$!

          # Wait for the process to finish or timeout
          if [[ -n "${{ inputs.timeout_minutes }}" ]]; then
            TIMEOUT=$(( ${{ inputs.timeout_minutes }} * 60 ))
            ( sleep $TIMEOUT && kill -HUP $PID ) 2>/dev/null &  # Kill the process after timeout
            WAIT_PID=$!
            wait $PID
            kill -HUP $WAIT_PID 2>/dev/null  # Clean up the timeout process
          else
            wait $PID
          fi

          if [ $? -eq 0 ]; then
            SUCCESS=true
            break
          fi

          ATTEMPTS=$((ATTEMPTS + 1))
          echo "Attempt $ATTEMPTS/$MAX_ATTEMPTS failed. Retrying..."
        done

        if [ "$SUCCESS" = false ]; then
          echo "All attempts failed."
          exit 1
        fi

    - name: Run Safety CLI to check for vulnerabilities
      uses: pyupio/safety-action@v1
      with:
        api-key: ${{ inputs.SAFETY_API_KEY }}
        args: --target ./${{ inputs.module }} --policy-file ./.safety-policy.yml
