name: Update Version and Build Docker Image

on:
  push:
    branches:
      - main
    paths:
      - version.txt
  workflow_dispatch:
    inputs:
      force_tag:
        description: "Force tag creation"
        type: choice
        default: "no"
        options:
          - "no"
          - "yes"

jobs:
  update-version:
    name: Update version
    runs-on: ubuntu-latest
    outputs:
      sha_tag: ${{ steps.set_outputs_for_next_jobs.outputs.sha }}
      version_tag: ${{ steps.set_outputs_for_next_jobs.outputs.version }}
      branch_name: ${{ steps.commit_new_version.outputs.branch_name }}

    env:
      SHA_TAG: ${{ github.sha }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Set up Python 3.11
        uses: actions/setup-python@v4
        with:
          python-version: "3.11"

      - name: Read version.txt
        id: read_version
        run: |
          echo "VERSION_TAG=$(cat version.txt)" >> $GITHUB_ENV

      - name: Update version in pyproject.toml & poetry.lock
        run: |
          python -m pip install --upgrade pip poetry
          echo "Updating all pyproject.toml with version ${{ env.VERSION_TAG}}"
          find . -name 'pyproject.toml' -type f -exec sed -i "s/^version.*/version = \"${{ env.VERSION_TAG}}\"/g" {} +
          for folder in */; do
            if [ -f "${folder}poetry.lock" ]; then
                echo "Found pyproject.toml in folder: ${folder}"
                (cd "${folder}" && poetry update)
            fi
          done
          poetry update

      - id: commit_new_version
        name: Commit and push modified files
        run: |
          MODIFIED_FILES=$(git diff --name-only HEAD)
          if [ -z "$MODIFIED_FILES" ]; then
            echo "No changes to commit."
          else
            git config --global user.email "actions@github.com"
            git config --global user.name "Github Actions"
            # TODO check to see that only **/pyproject.toml or ./version.txt were modified
            git add .
            if [ "${{ github.ref_name }}" == "main" ]; then
              BRANCH_NAME="${{ github.ref_name }}_v${{ env.VERSION_TAG}}"
              git checkout -b $BRANCH_NAME
              git commit -m "Update version number to ${{ env.VERSION_TAG}} by creating new branch: $BRANCH_NAME "
            else
              BRANCH_NAME=${{ github.ref_name }}
              git commit -m "Update version number to ${{ env.VERSION_TAG}} on ${{ github.ref_name }}"
            fi
            git push origin $BRANCH_NAME
            echo "SHA_TAG=$(git rev-parse HEAD)" >> $GITHUB_ENV
          fi
          echo "branch_name=${BRANCH_NAME}" >> $GITHUB_OUTPUT
      - id: set_outputs_for_next_jobs
        name: Set output for next jobs
        run: |
          echo "version=${{ env.VERSION_TAG}}" >> $GITHUB_OUTPUT
          echo "sha=${{ env.SHA_TAG }}" >> $GITHUB_OUTPUT

  build-test-docker-images:
    name: Build docker images, test images and push to Github container registry
    needs: update-version
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - {
              module: 03_uns_graphdb,
              image: uns/graphdb,
              container_description: "Stores MQTT messages to the graph database. Supports both UNS and SparkplugB",
            }
          - {
              module: 04_uns_historian,
              image: uns/historian,
              container_description: "Stores MQTT messages to the historian database. Supports both UNS and SparkplugB",
            }
          - {
              module: 05_sparkplugb,
              image: uns/spb_mapper,
              container_description: "Listens to the SparkplugB name space and translates them to UNS messages, then publishes to the UNS Namespace",
            }
          - {
              module: 06_uns_kafka,
              image: uns/kafka_mapper,
              container_description: "Listens to the UNS namespace, converts UNS topic to Kafka topic and publishes the message to Kafka",
            }
          - {
              module: 07_uns_graphql,
              image: uns/kafka_mapper,
              container_description: "Listens to the UNS namespace, converts UNS topic to Kafka topic and publishes the message to Kafka",
            }            

    env:
      SHA_TAG: ${{ needs.update-version.outputs.sha_tag }}
      VERSION_TAG: ${{ needs.update-version.outputs.version_tag }}
    steps:
      - name: Login to Github Container Registry
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Checkout Code
        uses: actions/checkout@v3
        with:
          ref: ${{ needs.update-version.outputs.sha_tag }}

      - name: Docker image tests
        run: |
          IFS=$'\n'
          module=${{ matrix.module }}
          image_name=${{ matrix.image }}

          cd "${module}"
          echo "Validating Docker Entry prior to build"
          entry_point=$(cat ./Dockerfile | grep "^ENTRYPOINT")
          if [[ ! "${entry_point}" =~ ^ENTRYPOINT\ \[\"poetry\",\ \"run\",\ \".+\"\]$ ]]; then
            echo "Error: Entry point should be in the format [\"poetry\", \"run\", \"<script_name>\"]"
            exit 1
          else
            echo "Entrypoint for docker is: ${entry_point}"
          fi

          script_name="$(echo "${entry_point}" | awk '{print $4}' | tr -d '"]')"
          if ! grep -q "^\[tool.poetry.scripts\]" ./pyproject.toml; then
            echo "Error: [tool.poetry.scripts] section not found in pyproject.toml"
            exit 1
          fi

          if ! grep -q "^${script_name} =" ./pyproject.toml; then
            echo "Error: Script entry for ${script_name} not found in [tool.poetry.scripts] section of pyproject.toml"
            exit 1
          else            
            echo "[tool.poetry.scripts] entry is: ${script_name}"
          fi

          main_entry=$(grep "^${script_name} =" ./pyproject.toml | awk '{print $3}' | tr -d '"')
          echo "Validate if ${main_entry} points to a valid python function"

          python_module=${main_entry%:*}
          function=${main_entry##*:}
          if [[ ! "${function}" == "main" ]]; then
            echo "Error: '${main_entry}' should map to a main function of python python_module"
            exit 1
          fi

          echo "Creating Docker: ${image_name}:${{env.SHA_TAG }}"
          docker build -t "${image_name}:${{env.SHA_TAG }}" -f ./Dockerfile ..

          # Run the Docker tests
          echo "Running tests for Docker image: ${image_name}::${{ env.SHA_TAG }}"
          docker run --entrypoint "sh" -e python_module="$python_module" -e function="$function" "${image_name}:${{ env.SHA_TAG }}" -c '
            if [ ! -d "/02_mqtt-cluster" ]; then
              echo "Error: Folder /02_mqtt-cluster not found in Docker image"
              exit 1
            else
              echo "Success:  Folder /02_mqtt-cluster is present"
            fi

            if [ ! "$(ls -AR /app/src | grep -E ".py$" | wc -l)" -gt "0" ]; then
              echo "Error: No .py files found in folder /app/src"
              exit 1
            else
              echo "Success:  Python Files are present"
            fi

            if [ ! -f "/app/pyproject.toml" ]; then
              echo "Error: pyproject.toml file not found in folder /app"
              exit 1
            else
              echo "Success:  pyproject.toml file found"
            fi

            if [ -d "/app/test" ]; then
              echo "Error: test folder not found in folder /app"
              exit 1
            else
              echo "Success:  test folder was not copied to the Docker"
            fi
            
            poetry run python -m compileall -q /app || (echo "Error: compileall failed" && exit 1)

            entry_valid=$(poetry run python -c "import ${python_module} as module;print( '\''${function}'\''  in dir(module))")
            if [ ! "$entry_valid" == "True" ];then
              echo "Error: Invalid main entry ${python_module}:${function}"
              exit 1
            fi
            echo "Docker image tests passed successfully"
          '

      - # Add support for more platforms with QEMU (optional)
        # https://github.com/docker/setup-qemu-action
        name: Set up QEMU
        uses: docker/setup-qemu-action@v2

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v2

      - name: Build Docker Image - Branches
        if: ${{ ! startsWith( github.ref_name , 'main') }}
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          platforms: linux/amd64,linux/arm64 # linux/arm/v7 not working, causes error: command 'gcc' failed: No such file or directory
          tags: |
            "ghcr.io/${{ github.repository }}/${{ matrix.image }}:${{ env.VERSION_TAG }}"
            "ghcr.io/${{ github.repository }}/${{ matrix.image }}:${{env.SHA_TAG }}"
          labels: |
            "annotations": { "org.opencontainers.image.description": ${{ matrix.container_description }} }
            "annotations": { "org.opencontainers.image.source" : https://github.com/mkashwin/unifiednamespace/tree/main/${{ matrix.image }} }
            "annotations": { "org.opencontainers.image.licenses" : MIT }
          file: ./${{ matrix.module }}/Dockerfile

      - name: Build Docker Image - Main
        if: ${{ startsWith( github.ref_name , 'main') }}
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          platforms: linux/amd64,linux/arm64 # linux/arm/v7 not working, causes error: command 'gcc' failed: No such file or directory
          tags: |
            "ghcr.io/${{ github.repository }}/${{ matrix.image }}:${{ env.VERSION_TAG }}"
            "ghcr.io/${{ github.repository }}/${{ matrix.image }}:${{env.SHA_TAG }}"
            "ghcr.io/${{ github.repository }}/${{ matrix.image }}:latest"
          labels: |
            "annotations": { "org.opencontainers.image.description": ${{ matrix.container_description }} }
            "annotations": { "org.opencontainers.image.source" : https://github.com/mkashwin/unifiednamespace/tree/main/${{ matrix.image }} }
            "annotations": { "org.opencontainers.image.licenses" : MIT }
          file: ./${{ matrix.module }}/Dockerfile

  create_tag:
    name: Tag the repository
    needs: [update-version, build-test-docker-images]
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Code
        uses: actions/checkout@v3
        with:
          ref: ${{ needs.update-version.outputs.sha_tag }}

      - name: Tag repository
        run: |
          if [ "${{ github.ref_name }}" == "main" ]; then
            # No changes made. We just need to tag (probably force tag)
            version="v${{ needs.update-version.outputs.version_tag }}"
          elif [ "${{ github.ref_name }}" == "main_v${{ needs.update-version.outputs.version_tag }}" ]; then
            version="v${{ needs.update-version.outputs.version_tag }}"
          else
            version=${{ github.ref_name }}_v${{  needs.update-version.outputs.version_tag }}
          fi
          git config --global user.email "actions@github.com"
          git config --global user.name "Github Actions"
          if [[ "${{ inputs.force_tag }}" == "yes" ]]; then
            git tag "$version" -m "Forced Tagging $version"
            git push origin "$version"  --force
          else
            git tag "$version" -m "Tagging $version"
            git push origin "$version"            
          fi

  create_pull_req:
    name: Create Pull Request if the tag was on main branch
    needs: [update-version, build-test-docker-images]
    runs-on: ubuntu-latest
    steps:
      - name: Checkout Code
        if: startsWith(needs.update-version.outputs.branch_name, 'main')
        uses: actions/checkout@v3
        with:
          ref: ${{ needs.update-version.outputs.sha_tag }}
          fetch-depth: 0

      - name: Raise Pull Request
        if: startsWith(needs.update-version.outputs.branch_name, 'main')
        uses: devops-infra/action-pull-request@v0.5.5
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          title: "Updating version to ${{ needs.update-version.outputs.version_tag }} "
          label: "v${{  needs.update-version.outputs.version_tag }}, version-update"
          source_branch: "${{ needs.update-version.outputs.branch_name }}"
          target_branch: main
          get_diff: true
