name: Update Version and Build Docker Image

on:
  push:
    branches:
      - main
    paths:
      - version.txt
  workflow_dispatch:
    branches:
      - main
      - release/*
      - docker_support
    inputs:
      force_tag:
        description: "Force tag creation"
        type: choice
        default: "no"
        options:
          - "no"
          - "yes"

jobs:
  update-version:
    name: Update version
    runs-on: ubuntu-latest
    outputs:
      sha_tag: ${{ steps.set_outputs_for_next_jobs.outputs.sha }}
      version_tag: ${{ steps.set_outputs_for_next_jobs.outputs.version }}

    env:
      SHA_TAG: ${{ github.sha }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Read version.txt
        id: read_version
        run: |
          echo "VERSION_TAG=$(cat version.txt)" >> $GITHUB_ENV

      - name: Update version in pyproject.toml
        run: |
          echo "Updating all pyproject.toml with version ${{ env.VERSION_TAG}}"
          find . -name 'pyproject.toml' -type f -exec sed -i "s/^version.*/version = \"${{ env.VERSION_TAG}}\"/g" {} +

      - name: Commit and push modified files
        id: commit_new_version
        run: |
          git config --global user.email "actions@github.com"
          git config --global user.name "Github Actions"
          git add .
          if ! git diff-index --quiet HEAD ; then
            git commit -m "Update version number to ${{ env.VERSION_TAG}}"
            git push origin ${{ github.ref }}
            echo "SHA_TAG=$(git rev-parse HEAD)" >> $GITHUB_ENV
          else
            echo "No changes to commit."

          fi
      - id: set_outputs_for_next_jobs
        name: Set output for next jobs
        run: |
          echo "version=${{ env.VERSION_TAG}}" >> $GITHUB_OUTPUT
          echo "sha=${{ env.SHA_TAG }}" >> $GITHUB_OUTPUT

  build-test-docker-images:
    name: Build docker images, test images and push to Github container registry
    needs: update-version
    runs-on: ubuntu-latest
    strategy:
      matrix:
        include:
          - { module: 03_uns_graphdb, image: uns/graphdb }
          - { module: 04_uns_historian, image: uns/historian }
          - { module: 05_sparkplugb, image: uns/spb_mapper }

    env:
      SHA_TAG: ${{ needs.update-version.outputs.sha_tag }}
      VERSION_TAG: ${{ needs.update-version.outputs.version_tag }}
    steps:
      - name: Login to Github Container Registry
        uses: docker/login-action@v2
        with:
          registry: ghcr.io
          username: ${{ github.repository_owner }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Checkout Code
        uses: actions/checkout@v3
        with:
          ref: ${{ needs.update-version.outputs.sha_tag }}

      - name: Build & Test Docker Image for module
        run: |
          IFS=$'\n'
          module=${{ matrix.module }}
          image_name=${{ matrix.image }}

          cd "${module}"
          echo "Validating Docker Entry prior to build"
          entry_point=$(cat ./Dockerfile | grep "^ENTRYPOINT")
          if [[ ! "${entry_point}" =~ ^ENTRYPOINT\ \[\"poetry\",\ \"run\",\ \".+\"\]$ ]]; then
            echo "Error: Entry point should be in the format [\"poetry\", \"run\", \"<script_name>\"]"
            exit 1
          else
            echo "Entrypoint for docker is: ${entry_point}"
          fi

          script_name="$(echo "${entry_point}" | awk '{print $4}' | tr -d '"]')"
          if ! grep -q "^\[tool.poetry.scripts\]" ./pyproject.toml; then
            echo "Error: [tool.poetry.scripts] section not found in pyproject.toml"
            exit 1
          fi

          if ! grep -q "^${script_name} =" ./pyproject.toml; then
            echo "Error: Script entry for ${script_name} not found in [tool.poetry.scripts] section of pyproject.toml"
            exit 1
          else            
            echo "[tool.poetry.scripts] entry is: ${script_name}"
          fi

          main_entry=$(grep "^${script_name} =" ./pyproject.toml | awk '{print $3}' | tr -d '"')
          echo "Validate if ${main_entry} points to a valid python function"

          python_module=${main_entry%:*}
          function=${main_entry##*:}
          if [[ ! "${function}" == "main" ]]; then
            echo "Error: '${main_entry}' should map to a main function of python python_module"
            exit 1
          fi

          echo "Creating Docker: ${image_name}:${{env.SHA_TAG }}"
          docker build -t "${image_name}:${{env.SHA_TAG }}" -f ./Dockerfile ..

          # Run the Docker tests
          echo "Running tests for Docker image: ${image_name}::${{ env.SHA_TAG }}"
          docker run --entrypoint "/bin/bash" -e python_module="$python_module" -e function="$function" "${image_name}:${{ env.SHA_TAG }}" -c '
            if [ ! -d "/02_mqtt-cluster" ]; then
              echo "Error: Folder /02_mqtt-cluster not found in Docker image"
              exit 1
            else
              echo "Success:  Folder /02_mqtt-cluster is present"
            fi

            if [ ! "$(ls -AR /app/src | grep -E ".py$" | wc -l)" -gt "0" ]; then
              echo "Error: No .py files found in folder /app/src"
              exit 1
            else
              echo "Success:  Python Files are present"
            fi

            if [ ! -f "/app/pyproject.toml" ]; then
              echo "Error: pyproject.toml file not found in folder /app"
              exit 1
            else
              echo "Success:  pyproject.toml file found"
            fi

            if [ -d "/app/test" ]; then
              echo "Error: test folder not found in folder /app"
              exit 1
            else
              echo "Success:  test folder was not copied to the Docker"
            fi
            
            poetry run python -m compileall -q /app || (echo "Error: compileall failed" && exit 1)

            entry_valid=$(poetry run python -c "import ${python_module} as module;print( '\''${function}'\''  in dir(module))")
            if [ ! "$entry_valid" == "True" ];then
              echo "Error: Invalid main entry ${python_module}:${function}"
              exit 1
            fi
            echo "Docker image tests passed successfully"
          '
          echo "Tests successful, proceeding to create additional tags: ${image_name}::${{ env.VERSION_TAG }} "
          docker tag "${image_name}:${{env.SHA_TAG }}" "${image_name}:${{ env.VERSION_TAG }}"
          docker tag "${image_name}:${{env.SHA_TAG }}" "ghcr.io/${{ github.repository }}/${image_name}:${{ env.VERSION_TAG }}"
          docker tag "${image_name}:${{env.SHA_TAG }}" "ghcr.io/${{ github.repository }}/${image_name}:${{env.SHA_TAG }}"
          if [ "${{ github.ref_name }}" == "main" ]; then
            docker tag "${image_name}:${{env.SHA_TAG }}" "ghcr.io/${{ github.repository }}/${image_name}:latest"
          else
            docker tag "${image_name}:${{env.SHA_TAG }}" "ghcr.io/${{ github.repository }}/${image_name}:${{ github.ref_name }}"
          fi

      - name: Push docker image to Github Container Registry
        run: |
          module=${{ matrix.module }}
          image_name=${{ matrix.image }}

          cd "${module}"
          docker image push --all-tags "ghcr.io/${{ github.repository }}/${image_name}"

  create_tag:
    name: Tag the repository
    needs: [update-version]
    runs-on: ubuntu-latest

    steps:
      - name: Checkout Code
        uses: actions/checkout@v3
        with:
          ref: ${{ needs.update-version.outputs.sha_tag }}

      - name: Tag repository
        run: |
          version=${{ needs.update-version.outputs.version_tag }}
          git config --global user.email "actions@github.com"
          git config --global user.name "Github Actions"
          if [[ "${{ inputs.force_tag }}" == "yes" ]]; then
            git tag "v$version" -m "Forced Tagging v$version"
            git push origin "v$version"  --force
          else
            git tag "v$version" -m "Tagging v$version"
            git push origin "v$version"           
          fi
