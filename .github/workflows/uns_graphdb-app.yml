# This workflow will install Python dependencies, run tests and lint with a single version of Python
# For more information see: https://help.github.com/actions/language-and-framework-guides/using-python-with-github-actions

name: UNS Graph DB MQTT Client

on:
  push:
    branches:
      - "**"
    paths:
      - "02_mqtt-cluster/**/*.py"
      - "02_mqtt-cluster/pyproject.toml"
      - "02_mqtt-cluster/poetry.lock"
      - "03_uns_graphdb/**/*.py"
      - "03_uns_graphdb/pyproject.toml"
      - "03_uns_graphdb/poetry.lock"
      - "03_uns_graphdb/Dockerfile"
      - ".github/workflows/uns_graphdb-app.yml"
  pull_request:
    branches:
      - "**"
    paths:
      - "02_mqtt-cluster/**/*.py"
      - "02_mqtt-cluster/pyproject.toml"
      - "02_mqtt-cluster/poetry.lock"
      - "03_uns_graphdb/**/*.py"
      - "03_uns_graphdb/pyproject.toml"
      - "03_uns_graphdb/poetry.lock"
      - "03_uns_graphdb/Dockerfile"
      - ".github/workflows/uns_graphdb-app.yml"
permissions:
  contents: read

jobs:
  generate_random_password:
    runs-on: ubuntu-latest
    outputs:
      neo4j_pwd: ${{ steps.random_strings.outputs.neo4j_pwd}}
    steps:
      - id: random_strings
        run: |
          echo "neo4j_pwd=$(openssl rand -base64 32 | tr -dc '[:alnum:]')" >> $GITHUB_OUTPUT
  build_code:
    runs-on: ubuntu-latest
    needs: generate_random_password
    env:
      UNS_mqtt__host: "localhost"
      UNS_mqtt__port: 1883
      UNS_graphdb__url: "bolt://localhost:7687"
      UNS_graphdb__username: "neo4j"
      UNS_graphdb__password: ${{ needs.generate_random_password.outputs.neo4j_pwd }}
    services:
      uns_mqtt:
        image: emqx/emqx:latest
        ports:
          - "1883:1883"
          - "8083:8083"
      uns_graphdb:
        image: neo4j:latest
        ports:
          - "7474:7474"
          - "7687:7687"
        env:
          NEO4J_AUTH: neo4j/${{ env.UNS_graphdb__password }}
          apoc.export.file.enabled: true
          apoc.import.file.enabled: true
          apoc.import.file.use_neo4j_config: true
          NEO4J_PLUGINS: '["apoc"]'

    steps:
      - uses: actions/checkout@v3
      - name: Set up Python 3.10
        uses: actions/setup-python@v4
        with:
          python-version: "3.10"
      - name: Install dependencies
        run: |
          cd ./03_uns_graphdb
          python -m pip install --upgrade pip
          pip install poetry
          poetry install

      - name: Lint with flake8
        run: |
          # change to current directory of module
          cd ./03_uns_graphdb
          # stop the build if there are Python syntax errors or undefined names
          poetry run flake8 ./src ./test --count --select=E9,F63,F7,F82 --show-source --statistics 
          # exit-zero treats all errors as warnings. The GitHub editor is 127 chars wide
          poetry run flake8 ./src ./test --count --exit-zero --max-complexity=10 --max-line-length=127 --statistics

      - name: Test for security vulnerabilities
        run: |
          # change to current directory of module
          cd ./03_uns_graphdb
          poetry run safety check

      - name: Test with pytest
        run: |
          cd ./03_uns_graphdb

          poetry run pytest ./test

  build_docker_image:
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v3
      - name: Install dependencies
        run: |
          module="03_uns_graphdb"
          image_name="uns/graphdb"

          cd "${module}"
          docker build -t "${ image_name }:${{ github.sha }}" -f ./Dockerfile ..
          cd "${module}"
          echo "Validating Docker Entry prior to build"
          entry_point=$(cat ./Dockerfile | grep "^ENTRYPOINT")
          if [[ ! "${entry_point}" =~ ^ENTRYPOINT\ \[\"poetry\",\ \"run\",\ \".+\"\]$ ]]; then
            echo "Error: Entry point should be in the format [\"poetry\", \"run\", \"<script_name>\"]"
            exit 1
          else
            echo "Entrypoint for docker is: ${entry_point}"
          fi

          script_name="$(echo "${entry_point}" | awk '{print $4}' | tr -d '"]')"
          if ! grep -q "^\[tool.poetry.scripts\]" ./pyproject.toml; then
            echo "Error: [tool.poetry.scripts] section not found in pyproject.toml"
            exit 1
          fi

          if ! grep -q "^${script_name} =" ./pyproject.toml; then
            echo "Error: Script entry for ${script_name} not found in [tool.poetry.scripts] section of pyproject.toml"
            exit 1
          else            
            echo "[tool.poetry.scripts] entry is: ${script_name}"
          fi

          main_entry=$(grep "^${script_name} =" ./pyproject.toml | awk '{print $3}' | tr -d '"')
          echo "Validate if ${main_entry} points to a valid python function"

          python_module=${main_entry%:*}
          function=${main_entry##*:}
          if [[ ! "${function}" == "main" ]]; then
            echo "Error: '${main_entry}' should map to a main function of python python_module"
            exit 1
          fi

          echo "Creating Docker: ${image_name}:${{env.SHA_TAG }}"
          docker build -t "${image_name}:${{env.SHA_TAG }}" -f ./Dockerfile ..

          # Run the Docker tests
          echo "Running tests for Docker image: ${image_name}::${{ env.SHA_TAG }}"
          docker run --entrypoint "/bin/bash" -e python_module="$python_module" -e function="$function" "${image_name}:${{ env.SHA_TAG }}" -c '
            if [ ! -d "/02_mqtt-cluster" ]; then
              echo "Error: Folder /02_mqtt-cluster not found in Docker image"
              exit 1
            else
              echo "Success:  Folder /02_mqtt-cluster is present"
            fi

            if [ ! "$(ls -AR /app/src | grep -E ".py$" | wc -l)" -gt "0" ]; then
              echo "Error: No .py files found in folder /app/src"
              exit 1
            else
              echo "Success:  Python Files are present"
            fi

            if [ ! -f "/app/pyproject.toml" ]; then
              echo "Error: pyproject.toml file not found in folder /app"
              exit 1
            else
              echo "Success:  pyproject.toml file found"
            fi

            if [ -d "/app/test" ]; then
              echo "Error: test folder not found in folder /app"
              exit 1
            else
              echo "Success:  test folder was not copied to the Docker"
            fi
            
            poetry run python -m compileall -q /app || (echo "Error: compileall failed" && exit 1)

            entry_valid=$(poetry run python -c "import ${python_module} as module;print( '\''${function}'\''  in dir(module))")
            if [ ! "$entry_valid" == "True" ];then
              echo "Error: Invalid main entry ${python_module}:${function}"
              exit 1
            fi
            echo "Docker image tests passed successfully"
          '
